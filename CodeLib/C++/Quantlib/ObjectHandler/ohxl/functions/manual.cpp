/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/* 
 Copyright (C) 2006, 2007, 2011 Eric Ehlers

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

// Excel functions coded by hand, to be registered with Excel
// alongside the autogenerated functions.

#include <oh/utilities.hpp>
#include <oh/exception.hpp>
#include <ohxl/repositoryxl.hpp>
#include <ohxl/conversions/all.hpp>
#include <ohxl/functioncall.hpp>
#include <ohxl/functions/functioncount.hpp>
#include <ohxl/xloper.hpp>
#include <map>
#include <algorithm>

#include "string"
#include "icrsint.h"
#include "comutil.h"
#include <comdef.h>
#include <vector>
#include <ohxl/convert_oper.hpp>
#import "C:\Program Files\Common Files\System\ADO\msado15.dll" \
	no_namespace rename("EOF", "adoEOF")


#define XLL_DEC extern "C"
#define SMALL_STRING_LEN 500



void operToOper(OPER *xTarget, const OPER *xSource) {
    if (xSource->xltype == xltypeNum) {
        xTarget->xltype = xltypeNum;
        xTarget->val.num = xSource->val.num;
        return;
    } else if (xSource->xltype == xltypeStr) {
        // Must use type unsigned char (BYTE) to process the 0th byte of Excel byte-counted string
        unsigned char len = xSource->val.str[0];
        xTarget->val.str = new char[ len + 1 ];
        xTarget->xltype = xltypeStr | xlbitDLLFree;
        xTarget->val.str[0] = len;
        if (len)
            strncpy(xTarget->val.str + 1, xSource->val.str + 1, len);
        return;
    } else if (xSource->xltype == xltypeBool) {
        xTarget->xltype = xltypeBool;
        //xTarget->val.boolean = xSource->val.boolean;
        xTarget->val.xbool = xSource->val.xbool;
        return;
    } else if (xSource->xltype == xltypeErr) {
        xTarget->xltype = xltypeErr;
        xTarget->val.err = xSource->val.err;
        return;
    } else if (xSource->xltype == xltypeNil) {
        xTarget->xltype = xltypeNil;
        return;
    } else if (xSource->xltype == xltypeInt) {
        xTarget->xltype = xltypeInt;
        xTarget->val.w = xSource->val.w;
        return;
    } else {
        OH_FAIL("operToOper: unexpected OPER type: " << xSource->xltype);
    }
}

std::string operToString(const OPER *xSource)
{
	unsigned char len = xSource->val.str[0];
	std::string strTarget(len + 1, 0);
	for (int i = 0; i < len; i++)
	{
		strTarget[i] = *(xSource->val.str+ i + 1);
	}
	strTarget[len] = '\0';
	return strTarget;
}


void validateReference(const XLOPER *xReference, const std::string &name) {
    OH_REQUIRE(xReference->xltype != xltypeErr && xReference->val.err != xlerrRef,
        "parameter '" << name << "' is not a valid range reference");
}

XLL_DEC long *ohTrigger(
        OPER *dummy0,
        OPER *dummy1,
        OPER *dummy2,
        OPER *dummy3,
        OPER *dummy4,
        OPER *dummy5,
        OPER *dummy6,
        OPER *dummy7,
        OPER *dummy8,
        OPER *dummy9) {

    boost::shared_ptr<ObjectHandler::FunctionCall> functionCall;

    try {
        functionCall = boost::shared_ptr<ObjectHandler::FunctionCall>
            (new ObjectHandler::FunctionCall("ohTrigger"));

        validateReference(dummy0, "dummy0");
        validateReference(dummy1, "dummy1");
        validateReference(dummy2, "dummy2");
        validateReference(dummy3, "dummy3");
        validateReference(dummy4, "dummy4");
        validateReference(dummy5, "dummy5");
        validateReference(dummy6, "dummy6");
        validateReference(dummy7, "dummy7");
        validateReference(dummy8, "dummy8");
        validateReference(dummy9, "dummy9");

        static long returnValue;
        static std::map<std::string, long> iterators;
        returnValue = iterators[ObjectHandler::FunctionCall::instance().addressString()]++;
        return &returnValue;

    } catch (const std::exception &e) {
        ObjectHandler::RepositoryXL::instance().logError(e.what(), functionCall);
        return 0;
    }
}

XLL_DEC long *ohFunctionCount() {
    static long returnValue = FUNCTION_COUNT;
    return &returnValue;
}

int countValidRows(const OPER &xMulti) {
    for (int numValidRows=xMulti.val.array.rows; numValidRows; --numValidRows) {
        for (int i=0; i<xMulti.val.array.columns; ++i) {
            int index = (numValidRows - 1) * xMulti.val.array.columns + i;
            if (!(xMulti.val.array.lparray[index].xltype & (xltypeErr | xltypeNil)))
                return numValidRows;
        }
    }
    return 1;
}

int countValidCols(const OPER &xMulti) {
    for (int numValidCols=xMulti.val.array.columns; numValidCols; --numValidCols) {
        for (int i=0; i<xMulti.val.array.rows; ++i) {
            int index = (numValidCols - 1) + i * xMulti.val.array.columns;
            if (!(xMulti.val.array.lparray[index].xltype & (xltypeErr | xltypeNil)))
                return numValidCols;
        }
    }
    return 1;
}

XLL_DEC OPER *ohPack(OPER *xInputRange) {

    // initialize Function Call object

    boost::shared_ptr<ObjectHandler::FunctionCall> functionCall;

    ObjectHandler::Xloper xMulti;
    static OPER xRet;
    xRet.val.array.lparray = 0;

    try {
        functionCall = boost::shared_ptr<ObjectHandler::FunctionCall>
            (new ObjectHandler::FunctionCall("ohPack"));

        Excel(xlCoerce, &xMulti, 2, xInputRange, TempInt(xltypeMulti));

        int numValidRows = countValidRows(xMulti());
        int numValidCols = countValidCols(xMulti());

        xRet.val.array.rows = numValidRows;
        xRet.val.array.columns = numValidCols;
        xRet.val.array.lparray = new OPER[numValidRows * numValidCols]; 
        xRet.xltype = xltypeMulti | xlbitDLLFree;

        for (int i=0; i<numValidRows; ++i) {
            for (int j=0; j<numValidCols; ++j) {
                int indexSource = i * xMulti->val.array.columns + j;
                int indexTarget = i * numValidCols + j;
                operToOper(&xRet.val.array.lparray[indexTarget], 
                    &xMulti->val.array.lparray[indexSource]);
            }
        }

        return &xRet;
    } catch (const std::exception &e) {

        // free any memory that may have been allocated

        if (xRet.xltype & xltypeMulti && xRet.val.array.lparray) {
            for (int i=0; i<xRet.val.array.columns * xRet.val.array.rows; ++i) {
                if (xRet.val.array.lparray[i].xltype & xltypeStr && xRet.val.array.lparray[i].val.str)
                    delete [] xRet.val.array.lparray[i].val.str;
            }
            delete [] xRet.val.array.lparray;
        }

        // log the exception and return a null pointer (#NUM!) to Excel

        ObjectHandler::RepositoryXL::instance().logError(e.what(), functionCall);
        return 0;
    }
}

bool rowIsValid(const OPER &xMulti, int i) {
    for (int j=0; j<xMulti.val.array.columns; ++j) {
        int index = i * xMulti.val.array.columns + j;
        if (xMulti.val.array.lparray[index].xltype & (xltypeErr | xltypeNil))
            return false;
    }
    return true;
}

int countValidRows2(const OPER &xMulti) {
    int ret = 0;
    for (int i=0; i<xMulti.val.array.rows; ++i)
        ret += rowIsValid(xMulti, i);
    return ret;
}

XLL_DEC OPER *ohRemoveInvalidRows(OPER *xInputRange) {

    // initialize Function Call object
    boost::shared_ptr<ObjectHandler::FunctionCall> functionCall;

    ObjectHandler::Xloper xMulti;
    static OPER xRet;
    xRet.val.array.lparray = 0;

    try {
        functionCall = boost::shared_ptr<ObjectHandler::FunctionCall>
            (new ObjectHandler::FunctionCall("ohRemoveInvalidRows"));

        Excel(xlCoerce, &xMulti, 2, xInputRange, TempInt(xltypeMulti));

        int numValidRows = countValidRows2(xMulti());
        if (!numValidRows) return 0;
        int numCols = xMulti->val.array.columns;

        xRet.val.array.rows = numValidRows;
        xRet.val.array.columns = numCols;
        xRet.val.array.lparray = new OPER[numValidRows * numCols]; 
        xRet.xltype = xltypeMulti | xlbitDLLFree;

        int i2 = 0;
        for (int i=0; i<xMulti->val.array.rows; ++i) {
            if (rowIsValid(xMulti(), i)) {
                for (int j=0; j<numCols; ++j) {
                    int indexSource = i * numCols + j;
                    int indexTarget = i2 * numCols + j;
                    operToOper(&xRet.val.array.lparray[indexTarget], 
                        &xMulti->val.array.lparray[indexSource]);
                }
                i2++;
            }
        }

        return &xRet;

    } catch (const std::exception &e) {

        // free any memory that may have been allocated

        if (xRet.xltype & xltypeMulti && xRet.val.array.lparray) {
            for (int i=0; i<xRet.val.array.columns * xRet.val.array.rows; ++i) {
                if (xRet.val.array.lparray[i].xltype & xltypeStr && xRet.val.array.lparray[i].val.str)
                    delete [] xRet.val.array.lparray[i].val.str;
            }
            delete [] xRet.val.array.lparray;
        }

        // log the exception and return a null pointer (#NUM!) to Excel

        ObjectHandler::RepositoryXL::instance().logError(e.what(), functionCall);
        return 0;
    }
}

bool columnIsValid(const OPER &xMulti, int j) {
    for (int i=0; i<xMulti.val.array.rows; ++i) {
        int index = i * xMulti.val.array.columns + j;
        if (xMulti.val.array.lparray[index].xltype & (xltypeErr | xltypeNil))
            return false;
    }
    return true;
}

int countValidColumns(const OPER &xMulti) {
    int ret = 0;
    for (int j=0; j<xMulti.val.array.columns; ++j)
        ret += columnIsValid(xMulti, j);
    return ret;
}

XLL_DEC OPER *ohRemoveInvalidColumns(OPER *xInputRange) {

    // initialize Function Call object
    boost::shared_ptr<ObjectHandler::FunctionCall> functionCall;

    ObjectHandler::Xloper xMulti;
    static OPER xRet;
    xRet.val.array.lparray = 0;

    try {
        functionCall = boost::shared_ptr<ObjectHandler::FunctionCall>
            (new ObjectHandler::FunctionCall("ohRemoveInvalidColumns"));

        Excel(xlCoerce, &xMulti, 2, xInputRange, TempInt(xltypeMulti));

        int numValidCols = countValidColumns(xMulti());
        if (!numValidCols) return 0;
        int numRows = xMulti->val.array.rows;

        xRet.val.array.rows = numRows;
        xRet.val.array.columns = numValidCols;
        xRet.val.array.lparray = new OPER[numRows * numValidCols]; 
        xRet.xltype = xltypeMulti | xlbitDLLFree;

        for (int i=0; i<xMulti->val.array.rows; ++i) {
			int j2 = 0;
            for (int j=0; j<xMulti->val.array.columns; ++j) {
				if (columnIsValid(xMulti(), j)) {
					int indexSource = i * xMulti->val.array.columns + j;
					int indexTarget = i * numValidCols + j2;
					operToOper(&xRet.val.array.lparray[indexTarget], 
						&xMulti->val.array.lparray[indexSource]);
					j2++;
				}
            }
        }

        return &xRet;

    } catch (const std::exception &e) {

        // free any memory that may have been allocated
        if (xRet.xltype & xltypeMulti && xRet.val.array.lparray) {
            for (int i=0; i<xRet.val.array.columns * xRet.val.array.rows; ++i) {
                if (xRet.val.array.lparray[i].xltype & xltypeStr && xRet.val.array.lparray[i].val.str)
                    delete [] xRet.val.array.lparray[i].val.str;
            }
            delete [] xRet.val.array.lparray;
        }

        // log the exception and return a null pointer (#NUM!) to Excel

        ObjectHandler::RepositoryXL::instance().logError(e.what(), functionCall);
        return 0;
    }
}

XLL_DEC OPER *ohFilter(
        OPER *xInput,
        OPER *flags) {

    // declare a shared pointer to the Function Call object

    boost::shared_ptr<ObjectHandler::FunctionCall> functionCall;

    try {

        // instantiate the Function Call object
    
        functionCall = boost::shared_ptr<ObjectHandler::FunctionCall>(
            new ObjectHandler::FunctionCall("ohFilter"));

        // convert input datatypes to C++ datatypes

        std::vector<bool> flagsCpp = ObjectHandler::operToVector<bool>(*flags, "flags");

        const OPER *xMulti;
        ObjectHandler::Xloper xTemp;
        if (xInput->xltype == xltypeMulti) {
            xMulti = xInput;
        } else {
            Excel(xlCoerce, &xTemp, 2, xInput, TempInt(xltypeMulti));
            xMulti = &xTemp;
        }

        int sizeInput = xMulti->val.array.rows * xMulti->val.array.columns;
        OH_REQUIRE(sizeInput == flagsCpp.size(),
            "size mismatch between value vector (" << sizeInput << 
            ") and flag vector (" << flagsCpp.size() << ")");


        static OPER xRet;
        xRet.val.array.rows = count(flagsCpp.begin(), flagsCpp.end(), true);
        xRet.val.array.columns = 1;
        xRet.val.array.lparray = new OPER[xRet.val.array.rows]; 
        xRet.xltype = xltypeMulti | xlbitDLLFree;

        int idx = 0;
        for (int i=0; i<sizeInput; i++) {
            if (flagsCpp[i]) {
                operToOper(&xRet.val.array.lparray[idx++], &xMulti->val.array.lparray[i]);
            }
        }

        return &xRet;

    } catch (const std::exception &e) {
        ObjectHandler::RepositoryXL::instance().logError(e.what(), functionCall);
        return 0;
    }
}

/*
ohRangeRetrieveError() - This implementation uses a couple of undocumented workarounds for an
undocumented Excel bug.
- ohRangeRetrieveError() requires macro capabilities (#)
- ohRangeRetrieveError() accepts an XLOPER* (range reference) as input
- Macro functions accepting XLOPER* are not recalculated reliably by Excel
- We implement 2 functions, ohRangeRetrieveError() is a non-macro function which uses xlUDF
  to call ohRetrieveErrorImpl() which is a macro function.  This indirection fools Excel
  into allowing ohRangeRetrieveError() to invoke macro privileges.  Thanks to Laurent Longre
  for publishing this technique.
- ohRangeRetrieveError() performs a dummy xlCoerce on the input XLOPER*.  If Excel has called 
  ohRangeRetrieveError() out of sequence, then the xlCoerce will return xlretUncalced, causing
  Excel to automatically re-call ohRangeRetrieveError() after the input range is updated.
*/

XLL_DEC XLOPER *ohRangeRetrieveError(XLOPER *xRange) {
    try {
        ObjectHandler::Xloper xTemp;
        Excel(xlCoerce, &xTemp, 1, xRange);
        static XLOPER xRet;
        if (xTemp->xltype & xltypeErr) {
            Excel(xlUDF, &xRet, 2, TempStrNoSize("\x13""ohRetrieveErrorImpl"), xRange);
            xRet.xltype |= xlbitXLFree;
        } else {
            ObjectHandler::scalarToOper(std::string(), xRet);
        }
        return &xRet;
    } catch (...) {
        return 0;
    }
}


// Use a shorter name in Aladdin
XLL_DEC XLOPER *alErr(XLOPER *xRange) {
	try {
		ObjectHandler::Xloper xTemp;
		Excel(xlCoerce, &xTemp, 1, xRange);
		static XLOPER xRet;
		if (xTemp->xltype & xltypeErr) {
			Excel(xlUDF, &xRet, 2, TempStrNoSize("\x13""ohRetrieveErrorImpl"), xRange);
			xRet.xltype |= xlbitXLFree;
		} else {
			ObjectHandler::scalarToOper(std::string(), xRet);
		}
		return &xRet;
	} catch (...) {
		return 0;
	}
}

XLL_DEC char *ohRetrieveErrorImpl(XLOPER *xRange) {
    try {
        std::string returnValue =
            ObjectHandler::RepositoryXL::instance().retrieveError(xRange);
        static char ret[XL_MAX_STR_LEN];
        ObjectHandler::stringToChar(returnValue, ret);
        return ret;
    } catch (...) {
        return 0;
    }
}

// The amount of space left on the stack.  Excel returns this value into an unsigned short.
// Usually the amount of available stack space exceeds USHRT_MAX (65535).  So normally this
// function always returns 65535.
XLL_DEC long *ohStack() {
    static long returnValue;
    XLOPER xRes;
    Excel4(xlStack, &xRes, 0);
    xRes.xltype = xltypeNum;
    returnValue = static_cast<unsigned short>(xRes.val.w);
    return &returnValue;
}


// Merge the Excel ranges(cols)
// Aladdin
XLL_DEC OPER *alMergeRange(OPER *xRange1, OPER *xRange2){
	// initialize Function Call object
	boost::shared_ptr<ObjectHandler::FunctionCall> functionCall;

	ObjectHandler::Xloper xMulti1, xMulti2;
	static OPER xRet;
	xRet.val.array.lparray = 0;
	int numRows = 0;
	int numValidCols1 = 0;
	int numValidCols2 = 0;
	int numValidRow1 = 0;
	int numValidRow2 = 0;
	int indexSource = 0;
	int indexTarget = 0;

	try {
		functionCall = boost::shared_ptr<ObjectHandler::FunctionCall>
			(new ObjectHandler::FunctionCall("alMergeRange"));

		Excel(xlCoerce, &xMulti1, 2, xRange1, TempInt(xltypeMulti));
		Excel(xlCoerce, &xMulti2, 2, xRange2, TempInt(xltypeMulti));

		numValidCols1 = countValidColumns(xMulti1());
		numValidCols2 = countValidColumns(xMulti2());
		OH_REQUIRE(numValidCols1==1,"The range to be merged must have only one valid col");
		OH_REQUIRE(numValidCols2==1,"The range to be merged must have only one valid col");

		numValidRow1 = countValidRows(xMulti1());
		numValidRow2 = countValidRows(xMulti2());
		numRows = numValidRow1 + numValidRow2;

		OH_REQUIRE(numValidRow1>=1,"The range to be merged must have at least one valid row");
		OH_REQUIRE(numValidRow2>=1,"The range to be merged must have at least one valid row");

		xRet.val.array.rows = numRows;
		xRet.val.array.columns = 1; //only one col
		xRet.val.array.lparray = new OPER[numRows]; 
		xRet.xltype = xltypeMulti | xlbitDLLFree;

		for (int i=0; i < xMulti1->val.array.rows + xMulti2->val.array.rows; ++i) {
			if( i< xMulti1->val.array.rows && rowIsValid(xMulti1(),i))
			{
				indexSource = i;
				operToOper(&xRet.val.array.lparray[indexTarget], 
					&xMulti1->val.array.lparray[indexSource]);
				indexTarget += 1;
			}
			else if(rowIsValid(xMulti2(),i-xMulti1->val.array.rows))
			{
				indexSource = i-xMulti1->val.array.rows ;
				operToOper(&xRet.val.array.lparray[indexTarget], 
					&xMulti2->val.array.lparray[indexSource]);
				indexTarget += 1;
			}
		}

		return &xRet;

	} catch (const std::exception &e) {

		// free any memory that may have been allocated

		if (xRet.xltype & xltypeMulti && xRet.val.array.lparray) {
			for (int i=0; i<xRet.val.array.columns * xRet.val.array.rows; ++i) {
				if (xRet.val.array.lparray[i].xltype & xltypeStr && xRet.val.array.lparray[i].val.str)
					delete [] xRet.val.array.lparray[i].val.str;
			}
			delete [] xRet.val.array.lparray;
		}

		// log the exception and return a null pointer (#NUM!) to Excel

		ObjectHandler::RepositoryXL::instance().logError(e.what(), functionCall);
		return 0;
	}
}

_RecordsetPtr alConnectToAccess(char *DatabasePath, char *SQLscript){
	// initialize Function Call object
	boost::shared_ptr<ObjectHandler::FunctionCall> functionCall;

	std::string DatabasePathCpp(DatabasePath);
	std::string SQLscriptCpp(SQLscript);

	// Initialize the Access connection pointer 
	::CoInitialize(NULL);
	_ConnectionPtr m_pConnection;

	// Initialize the Recordset pointer
	_RecordsetPtr m_pRecordset;
	m_pRecordset.CreateInstance("ADODB.Recordset");

	HRESULT hr = m_pConnection.CreateInstance("ADODB.Connection");

	if (SUCCEEDED(hr) && !(DatabasePathCpp == ""))
	{
		m_pConnection->CursorLocation = adUseClient;

		std::string strFileType = DatabasePathCpp.substr(DatabasePathCpp.find(".",DatabasePathCpp.length() - 6));
		BSTR bstDatabasePath;

		if (".accdb" == strFileType)
		{
			bstDatabasePath = "Provider = Microsoft.ACE.OLEDB.12.0; Data Source =" + _bstr_t(_com_util::ConvertStringToBSTR(DatabasePathCpp.c_str()));
		}
		else if (".mdb" == strFileType)
		{
			bstDatabasePath = "Provider = Microsoft.Jet.OLEDB.4.0; Data Source =" + _bstr_t(_com_util::ConvertStringToBSTR(DatabasePathCpp.c_str()));
		}
		else
		{
			OH_REQUIRE(".accdb" == strFileType || ".mdb" == strFileType ,"The Input File Version cannot be recognized(accdb/mdb)!");
		}

		hr = m_pConnection->Open(_bstr_t(bstDatabasePath), "", "", adModeUnknown);
	}

	if(SUCCEEDED(hr) && !(SQLscriptCpp == ""))
	{
		_variant_t RecordsAffected;

		BSTR bstSQL = _bstr_t(_com_util::ConvertStringToBSTR(SQLscriptCpp.c_str()));

		hr = m_pConnection->Execute(bstSQL, &RecordsAffected, adCmdText);

		m_pRecordset = m_pConnection->Execute(bstSQL, &RecordsAffected, adCmdText);
		return m_pRecordset;
	}
}

XLL_DEC long *alReadFromAccessCount (char *DatabasePath, char *SQLscript){

	// initialize Function Call object
	boost::shared_ptr<ObjectHandler::FunctionCall> functionCall;

	//Initialize the Access Recordset Pointer
	_RecordsetPtr m_pRecordset;
	m_pRecordset.CreateInstance("ADODB.Recordset");

	long recordCount = 0;

	try
	{
		functionCall = boost::shared_ptr<ObjectHandler::FunctionCall>
			(new ObjectHandler::FunctionCall("alReadFromAccess"));

		if(strcmp(DatabasePath,"") != 0 && strcmp(SQLscript,"") != 0){
			m_pRecordset = alConnectToAccess(DatabasePath, SQLscript);
			m_pRecordset->get_RecordCount(&recordCount);

			// Close the RecordSet Interface
			if(m_pRecordset->State)
				m_pRecordset.Release();
			m_pRecordset = NULL;

			return &recordCount;
		}
		else
		{
			OH_REQUIRE(strcmp(DatabasePath,"") != 0,"The path of database cannot be blank!");
			OH_REQUIRE(strcmp(SQLscript,"") != 0,"The SQL query sentence cannot be blank!");

			// Close the RecordSet Interface
			if(m_pRecordset->State)
				m_pRecordset.Release();
			m_pRecordset = NULL;

			return NULL;
		}
	}
	catch(_com_error &e)
	{
		// Close the RecordSet Interface
		if(m_pRecordset->State)
			m_pRecordset.Release();
		m_pRecordset = NULL;

		ObjectHandler::RepositoryXL::instance().logError((LPCSTR)e.Description(), functionCall);
		return 0;
	}catch(const std::exception &e)
	{
		// Close the RecordSet Interface
		if(m_pRecordset->State)
			m_pRecordset.Release();
		m_pRecordset = NULL;

		ObjectHandler::RepositoryXL::instance().logError(e.what(), functionCall);
		return 0;
	}catch (...) {

		// Close the RecordSet Interface
		if(m_pRecordset->State)
			m_pRecordset.Release();
		m_pRecordset = NULL;

		ObjectHandler::RepositoryXL::instance().logError("Unknown error type", functionCall);
		return 0;
	}
}

XLL_DEC OPER *alReadFromAccess (char *DatabasePath, char *SQLscript, bool *TableHead){

	// initialize Function Call object
	boost::shared_ptr<ObjectHandler::FunctionCall> functionCall;

	bool bTableHead;

	_RecordsetPtr m_pRecordset;
	m_pRecordset.CreateInstance("ADODB.Recordset");

	static OPER xRet;
	xRet.val.array.rows = 1;
	xRet.val.array.columns = 1;  
	xRet.val.array.lparray = (OPER*) malloc(1*sizeof(OPER));
	xRet.xltype = xltypeMulti | xlbitDLLFree;

	try
	{
		functionCall = boost::shared_ptr<ObjectHandler::FunctionCall>
		(new ObjectHandler::FunctionCall("alReadFromAccess"));

		bTableHead = *TableHead;
		
		if (strcmp(DatabasePath,"") != 0 && strcmp(SQLscript,"") != 0)
		{
			_variant_t RecordsAffected;

			m_pRecordset = alConnectToAccess(DatabasePath, SQLscript);

			long numRows = 0;
			long numCols = 0;

			numCols = m_pRecordset->Fields ->Count;
			m_pRecordset->get_RecordCount(&numRows);

			if (bTableHead)
			{
				xRet.val.array.rows = numRows + 1;
				xRet.val.array.columns = numCols;
				xRet.val.array.lparray = new OPER[(numRows + 1) * numCols]; 
				xRet.xltype = xltypeMulti | xlbitDLLFree;
			}
			else
			{
				xRet.val.array.rows = numRows;
				xRet.val.array.columns = numCols;
				xRet.val.array.lparray = new OPER[numRows * numCols]; 
				xRet.xltype = xltypeMulti | xlbitDLLFree;
			}		

			long validcols = 0;

			if (bTableHead)
			{
				validcols = numCols;
				for (long i = 0; i < numCols; i++)
				{
					std::string strTableName = m_pRecordset->Fields->GetItem(i)->GetName();
					xRet.val.array.lparray[i].val.str = new char[strTableName.length() + 1];
					xRet.val.array.lparray[i].xltype = xltypeStr | xlbitDLLFree;
					xRet.val.array.lparray[i].val.str[0] = strTableName.length();
					if (strTableName.length())
					{
						strncpy(xRet.val.array.lparray[i].val.str + 1, strTableName.c_str(), strTableName.length());
					}
				}			
			}

			for(long j = 0; j < numRows; j++)
			{
				for(long i = 0; i < numCols; i++)
				{
					std::string strTemp = (LPSTR)(LPCSTR)_bstr_t(m_pRecordset->GetCollect(_variant_t(long(i))));
					unsigned char len = strTemp[0];
					xRet.val.array.lparray[j * numCols + i + validcols].val.str = new char[len + 1];
					xRet.val.array.lparray[j * numCols + i + validcols].xltype = xltypeStr | xlbitDLLFree;
					xRet.val.array.lparray[j * numCols + i + validcols].val.str[0] = len;
					if (len)
					{
						strncpy(xRet.val.array.lparray[j * numCols + i + validcols].val.str + 1, strTemp.c_str(), len);
					}
				
				}			
				m_pRecordset->MoveNext();
			}

			// Close the RecordSet Interface
			if(m_pRecordset->State)
				m_pRecordset.Release();
			m_pRecordset = NULL;

			return &xRet;
		}
		else
		{
			OH_REQUIRE(strcmp(DatabasePath,"") != 0,"The path of database cannot be blank!");
			OH_REQUIRE(strcmp(SQLscript,"") != 0,"The SQL query sentence cannot be blank!");

			// Close the RecordSet Interface
			if(m_pRecordset->State)
				m_pRecordset.Release();
			m_pRecordset = NULL;
		}
	}
	catch(_com_error &e)
	{
		// free any memory that may have been allocated
		if (xRet.xltype & xltypeMulti && xRet.val.array.lparray) {
			for (int i=0; i<xRet.val.array.columns * xRet.val.array.rows; ++i) {
				if (xRet.val.array.lparray[i].xltype & xltypeStr && xRet.val.array.lparray[i].val.str)
					delete [] xRet.val.array.lparray[i].val.str;
			}
			delete [] xRet.val.array.lparray;
		}

		// Close the RecordSet Interface
		if(m_pRecordset->State)
			m_pRecordset.Release();
		m_pRecordset = NULL;

		if ((std::string((LPCSTR)e.Description())).substr(0,42) == "Microsoft Jet 数据库引擎找不到输入表或查询")
		{
			ObjectHandler::RepositoryXL::instance().logError("Cannot find table matching the name in the database.", functionCall);
		} 
		else
		{
			ObjectHandler::RepositoryXL::instance().logError((LPCSTR)e.Description(), functionCall);
		}
		
		return 0;
	}catch(const std::exception &e)
	{
		// free any memory that may have been allocated
		if (xRet.xltype & xltypeMulti && xRet.val.array.lparray) {
			for (int i=0; i<xRet.val.array.columns * xRet.val.array.rows; ++i) {
				if (xRet.val.array.lparray[i].xltype & xltypeStr && xRet.val.array.lparray[i].val.str)
					delete [] xRet.val.array.lparray[i].val.str;
			}
			delete [] xRet.val.array.lparray;
		}

		// Close the RecordSet Interface
		if(m_pRecordset->State)
			m_pRecordset.Release();
		m_pRecordset = NULL;

		ObjectHandler::RepositoryXL::instance().logError(e.what(), functionCall);
		return 0;
	}catch (...) {
		// free any memory that may have been allocated
		if (xRet.xltype & xltypeMulti && xRet.val.array.lparray) {
			for (int i=0; i<xRet.val.array.columns * xRet.val.array.rows; ++i) {
				if (xRet.val.array.lparray[i].xltype & xltypeStr && xRet.val.array.lparray[i].val.str)
					delete [] xRet.val.array.lparray[i].val.str;
			}
			delete [] xRet.val.array.lparray;
		}

		// Close the RecordSet Interface
		if(m_pRecordset->State)
			m_pRecordset.Release();
		m_pRecordset = NULL;

		ObjectHandler::RepositoryXL::instance().logError("Unknown error type", functionCall);
		return 0;
	}
}


XLL_DEC char *alWriteToAccess (char* DatabasePath, char* TableName, OPER *DataHead, OPER *DataSet)
{
	// Initialize Function Call Object
	boost::shared_ptr<ObjectHandler::FunctionCall> functionCall;

	// Declare variables
	std::string DatabasePathCpp;
	std::string TableNameCpp;

	ObjectHandler::Xloper xMultiHead;
	ObjectHandler::Xloper xMultiSet;

	int numValidColsHead = 0;
	int numValidRowsHead = 0;
	int numValidColsSet = 0;
	int numValidRowsSet = 0;

	// Initialize the Access Connection Pointer
	::CoInitialize(NULL);
	_ConnectionPtr m_pConnection;	

	// Initialize the RecordSet pointer
	_RecordsetPtr m_pRecordset;
	m_pRecordset.CreateInstance("ADODB.Recordset");

	try
	{
		functionCall = boost::shared_ptr<ObjectHandler::FunctionCall>
			(new ObjectHandler::FunctionCall("alWriteToAccess"));

		// Convert char* to String version
		DatabasePathCpp = DatabasePath;
		TableNameCpp = TableName;

		// Open the Connection of Access
		HRESULT hr = m_pConnection.CreateInstance("ADODB.Connection");

		// Retrieve Data from the EXCEL
		Excel(xlCoerce, &xMultiHead, 2, DataHead, TempInt(xltypeMulti));
		Excel(xlCoerce, &xMultiSet, 2, DataSet, TempInt(xltypeMulti));

		//Judge the input fields validation
		numValidColsHead = xMultiHead -> val.array.columns;
		numValidRowsHead = xMultiHead -> val.array.rows;
		OH_REQUIRE(numValidColsHead > 0,"The input fields has less than 1 columns");
		OH_REQUIRE(numValidRowsHead > 0,"The input fields has less than 1 rows");
		OH_REQUIRE(numValidColsHead == countValidColumns(xMultiHead()),"The input fields exists invalid cells!");
		OH_REQUIRE(numValidRowsHead == 1,"The input fields should only be one rows");

		//Judge the input data validation
		numValidColsSet = xMultiSet -> val.array.columns;
		numValidRowsSet = xMultiSet -> val.array.rows;
		OH_REQUIRE(numValidColsSet > 0,"The input data area should not be less than 1 columns");
		OH_REQUIRE(numValidRowsSet > 0,"The input data area should not be less than 1 rows");
		OH_REQUIRE(numValidColsSet == countValidColumns(xMultiSet()),"The input data area exists invalid cells!");
		OH_REQUIRE(numValidRowsSet == countValidRows(xMultiSet()),"The input data area exists invalid cells!");

		if (SUCCEEDED (hr) && !(DatabasePathCpp == ""))
		{
			std::string fileType = DatabasePathCpp.substr(DatabasePathCpp.find(".",0));
			m_pConnection->CursorLocation = adUseClient;
			BSTR bstDatabasePath;
			if (".accdb" == fileType)
			{
				bstDatabasePath = "Provider = Microsoft.ACE.OLEDB.12.0; Data Source =" + _bstr_t(_com_util::ConvertStringToBSTR(DatabasePathCpp.c_str()));
			}
			else if (".mdb" == fileType)
			{
				bstDatabasePath = "Provider = Microsoft.Jet.OLEDB.4.0; Data Source =" + _bstr_t(_com_util::ConvertStringToBSTR(DatabasePathCpp.c_str()));
			}
			else
			{
				OH_REQUIRE(".accdb" == fileType || ".mdb" == fileType ,"The version of input file cannot be recognized!(accdb/mdb)");
			}
			
			hr = m_pConnection->Open(_bstr_t(bstDatabasePath), "", "", adModeUnknown);
		}

		// Retrieve the Keywords from the TableHead
		std::string *pKeyWords = new std::string[numValidColsHead];
		for (int i = 0; i < numValidColsHead; i++)
		{
			pKeyWords[i] = operToString(&xMultiHead->val.array.lparray[i]);
		}

		if (TableNameCpp != "")
		{
			// Open the Table
			_bstr_t bstSQLQuery = "SELECT * FROM "+ _bstr_t(_com_util::ConvertStringToBSTR(TableNameCpp.c_str()));
			m_pRecordset->Open(bstSQLQuery, m_pConnection.GetInterfacePtr(),adOpenDynamic,adLockOptimistic,adCmdText);
		}
		

		//Retrieve the fields from the Recordset
		FieldsPtr fields = m_pRecordset->GetFields();
		OH_REQUIRE(numValidColsHead == fields->Count,"The input fields don't match the Access table!");

		//Execute the input operations
		for (int i = 0; i < numValidRowsSet; i++ )
		{
			_bstr_t bstInsert = "INSERT INTO " + _bstr_t(_com_util::ConvertStringToBSTR(TableNameCpp.c_str())) + " (";
			for (int j = 0; j < numValidColsHead; j++)
			{
				bstInsert += _bstr_t(_com_util::ConvertStringToBSTR(pKeyWords[j].c_str()));
				if (j != numValidColsHead - 1)
				{
					bstInsert += ",";
				}	
			}
			bstInsert += ") VALUES (";
			for (int j = 0; j < numValidColsSet; j++)
			{
				if (xMultiSet->val.array.lparray[i * numValidColsSet + j].xltype == 2)
				{
					std::string strTemp = operToString(&xMultiSet->val.array.lparray[i * numValidColsSet + j]);
					bstInsert = bstInsert + "'" + _bstr_t(_com_util::ConvertStringToBSTR(strTemp.c_str())) + "'";
				}
				else if (xMultiSet->val.array.lparray[i * numValidColsSet + j].xltype == 1)
				{
					bstInsert += _bstr_t(xMultiSet->val.array.lparray[i * numValidColsSet + j].val.num);
				}
				if (j != numValidColsSet - 1)
				{
					bstInsert += ",";
				}
			}
			bstInsert += ")";

			_variant_t RecordsAffected;
			HRESULT hr = m_pConnection->Execute(bstInsert, &RecordsAffected, adCmdText);			
		}

		// Close all pointers
		delete[] pKeyWords;

		if(m_pRecordset->State)
			m_pRecordset.Release();
		m_pRecordset = NULL;

		if(m_pConnection->State)
			m_pConnection->Close();
		m_pConnection= NULL;

		//Judge the operation success or not
		if (SUCCEEDED(hr))
		{
			return "ContribSuccess";
		}
		else
		{
			return "ContribFailed";
		}
	}
	catch(_com_error &e)
	{
		// Close all pointers
		if(m_pRecordset->State)
			m_pRecordset.Release();
		m_pRecordset = NULL;

		if(m_pConnection->State)
			m_pConnection->Close();
		m_pConnection= NULL;

		ObjectHandler::RepositoryXL::instance().logError((LPCSTR)e.Description(), functionCall);
		return 0;
	}
	catch(const std::exception &e)
	{
		// Close all pointers
		if(m_pRecordset->State)
			m_pRecordset.Release();
		m_pRecordset = NULL;

		if(m_pConnection->State)
			m_pConnection->Close();
		m_pConnection= NULL;

		ObjectHandler::RepositoryXL::instance().logError(e.what(), functionCall);
		return 0;
	}catch (...) 
	{
		// Close all pointers
		if(m_pRecordset->State)
			m_pRecordset.Release();
		m_pRecordset = NULL;

		if(m_pConnection->State)
			m_pConnection->Close();
		m_pConnection= NULL;

		ObjectHandler::RepositoryXL::instance().logError("Unknown Error Type", functionCall);
		return 0;
	}
}



XLL_DEC OPER *alReadFromMySQL(char *DB_add, char *Ac_name, char *Ac_psw, char *DB_name, char *SQL_query, char *DB_port, bool *Table_head){

	//Initialize function call object
	boost::shared_ptr<ObjectHandler::FunctionCall> functionCall;

	CoInitialize(NULL);
	_ConnectionPtr m_pConnection;
	m_pConnection.CreateInstance(__uuidof(Connection));
	m_pConnection->CursorLocation=adUseClient;

	try
	{
		functionCall = boost::shared_ptr<ObjectHandler::FunctionCall>
			(new ObjectHandler::FunctionCall("alReadFromMySQL"));

		m_pConnection->ConnectionTimeout = 5;

		BSTR bst_DB_path;
		bst_DB_path = "Provider=MSDASQL;DRIVER={MySQL ODBC 5.3 Unicode Driver};Server=" + _bstr_t(DB_add) + ";Database=" + _bstr_t(DB_name) + ";PORT=" + _bstr_t(DB_port);
		HRESULT hr = m_pConnection->Open(bst_DB_path,_bstr_t(Ac_name), _bstr_t(Ac_psw),adModeUnknown);

		_RecordsetPtr m_pRecordset;
		m_pRecordset.CreateInstance(__uuidof(Recordset));
		m_pRecordset = m_pConnection->Execute(_bstr_t(SQL_query),NULL,adCmdText);
		/*m_pRecordset->Open(_bstr_t(SQL_query), m_pConnection.GetInterfacePtr(),adOpenDynamic,adLockOptimistic,adCmdText);*/


		static OPER xRet;
		xRet.val.array.rows = 1;
		xRet.val.array.columns = 1;  
		xRet.val.array.lparray = (OPER*) malloc(1*sizeof(OPER));
		xRet.xltype = xltypeMulti | xlbitDLLFree;

		long numRows = 0;
		long numCols = 0;

		numCols = m_pRecordset->Fields ->Count;

		m_pRecordset->get_RecordCount(&numRows);

		if (*Table_head)
		{
			xRet.val.array.rows = numRows + 1;
			xRet.val.array.columns = numCols;
			xRet.val.array.lparray = new OPER[(numRows + 1) * numCols]; 
			xRet.xltype = xltypeMulti | xlbitDLLFree;
		}
		else
		{
			xRet.val.array.rows = numRows;
			xRet.val.array.columns = numCols;
			xRet.val.array.lparray = new OPER[numRows * numCols]; 
			xRet.xltype = xltypeMulti | xlbitDLLFree;
		}

		long validcols = 0;

		if (*Table_head)
		{
			validcols = numCols;
			for (long i = 0; i < numCols; i++)
			{
				std::string strTableName = m_pRecordset->Fields->GetItem(i)->GetName();
				xRet.val.array.lparray[i].val.str = new char[strTableName.length() + 1];
				xRet.val.array.lparray[i].xltype = xltypeStr | xlbitDLLFree;
				xRet.val.array.lparray[i].val.str[0] = strTableName.length();
				if (strTableName.length())
				{
					strncpy(xRet.val.array.lparray[i].val.str + 1, strTableName.c_str(), strTableName.length());
				}
			}			
		}

		for(long j = 0; j < numRows; j++)
		{
			for(long i = 0; i < numCols; i++)
			{
				std::string strTemp = (LPSTR)(LPCSTR)_bstr_t(m_pRecordset->GetCollect(_variant_t(long(i))));
				unsigned char len = strTemp[0];
				xRet.val.array.lparray[j * numCols + i + validcols].val.str = new char[len + 1];
				xRet.val.array.lparray[j * numCols + i + validcols].xltype = xltypeStr | xlbitDLLFree;
				xRet.val.array.lparray[j * numCols + i + validcols].val.str[0] = len;
				if (len)
				{
					strncpy(xRet.val.array.lparray[j * numCols + i + validcols].val.str + 1, strTemp.c_str(), len);
				}

			}			
			m_pRecordset->MoveNext();
		}

		// Close the RecordSet Interface
		if(m_pRecordset->State)
			m_pRecordset.Release();
		m_pRecordset = NULL;

		return &xRet;
	}
	catch (_com_error e)
	{
		ObjectHandler::RepositoryXL::instance().logError((LPCSTR)e.Description(), functionCall);
		return 0;
	}
	catch (...)
	{
		ObjectHandler::RepositoryXL::instance().logError("Unknown Error Type", functionCall);
		return 0;
	}
}


XLL_DEC char *alWriteToMySQL (char *DB_add, char *Ac_name, char *Ac_psw, char *DB_name, char *DB_port, char* TableName, OPER *DataHead, OPER *DataSet)
{
	// Initialize Function Call Object
	boost::shared_ptr<ObjectHandler::FunctionCall> functionCall;

	ObjectHandler::Xloper xMultiHead;
	ObjectHandler::Xloper xMultiSet;

	int numValidColsHead = 0;
	int numValidRowsHead = 0;
	int numValidColsSet = 0;
	int numValidRowsSet = 0;

	// Initialize the Access Connection Pointer
	::CoInitialize(NULL);
	_ConnectionPtr m_pConnection;	

	// Initialize the RecordSet pointer
	_RecordsetPtr m_pRecordset;
	m_pRecordset.CreateInstance("ADODB.Recordset");

	try
	{
		functionCall = boost::shared_ptr<ObjectHandler::FunctionCall>
			(new ObjectHandler::FunctionCall("alWriteToMySQL"));

		// Convert char* to String version
		std::string TableNameCpp;
		TableNameCpp = TableName;

		// Open the Connection of Access
		HRESULT hr = m_pConnection.CreateInstance("ADODB.Connection");

		// Retrieve Data from the EXCEL
		Excel(xlCoerce, &xMultiHead, 2, DataHead, TempInt(xltypeMulti));
		Excel(xlCoerce, &xMultiSet, 2, DataSet, TempInt(xltypeMulti));

		//Judge the input fields validation
		numValidColsHead = xMultiHead -> val.array.columns;
		numValidRowsHead = xMultiHead -> val.array.rows;
		OH_REQUIRE(numValidColsHead > 0,"The input fields has less than 1 columns");
		OH_REQUIRE(numValidRowsHead > 0,"The input fields has less than 1 rows");
		OH_REQUIRE(numValidColsHead == countValidColumns(xMultiHead()),"The input fields exists invalid cells!");
		OH_REQUIRE(numValidRowsHead == 1,"The input fields should only be one rows");

		//Judge the input data validation
		numValidColsSet = xMultiSet -> val.array.columns;
		numValidRowsSet = xMultiSet -> val.array.rows;
		OH_REQUIRE(numValidColsSet > 0,"The input data area should not be less than 1 columns");
		OH_REQUIRE(numValidRowsSet > 0,"The input data area should not be less than 1 rows");
		OH_REQUIRE(numValidColsSet == countValidColumns(xMultiSet()),"The input data area exists invalid cells!");
		OH_REQUIRE(numValidRowsSet == countValidRows(xMultiSet()),"The input data area exists invalid cells!");

		if (SUCCEEDED (hr))
		{
			BSTR bst_DB_path;
			bst_DB_path = "Provider=MSDASQL;DRIVER={MySQL ODBC 5.3 Unicode Driver};Server=" + _bstr_t(DB_add) + ";Database=" + _bstr_t(DB_name) + ";PORT=" + _bstr_t(DB_port);
			HRESULT hr = m_pConnection->Open(bst_DB_path,_bstr_t(Ac_name), _bstr_t(Ac_psw),adModeUnknown);
		}

		// Retrieve the Keywords from the TableHead
		std::string *pKeyWords = new std::string[numValidColsHead];
		for (int i = 0; i < numValidColsHead; i++)
		{
			pKeyWords[i] = operToString(&xMultiHead->val.array.lparray[i]);
		}

		if (TableNameCpp != "")
		{
			// Open the Table
			_bstr_t bstSQLQuery = "SELECT * FROM "+ _bstr_t(_com_util::ConvertStringToBSTR(TableNameCpp.c_str()));
			m_pRecordset->Open(bstSQLQuery, m_pConnection.GetInterfacePtr(),adOpenDynamic,adLockOptimistic,adCmdText);
		}


		//Retrieve the fields from the Recordset
		FieldsPtr fields = m_pRecordset->GetFields();
		OH_REQUIRE(numValidColsHead == fields->Count,"The input fields don't match the Access table!");

		//Execute the input operations
		for (int i = 0; i < numValidRowsSet; i++ )
		{
			_bstr_t bstInsert = "INSERT INTO " + _bstr_t(_com_util::ConvertStringToBSTR(TableNameCpp.c_str())) + " (";
			for (int j = 0; j < numValidColsHead; j++)
			{
				bstInsert += _bstr_t(_com_util::ConvertStringToBSTR(pKeyWords[j].c_str()));
				if (j != numValidColsHead - 1)
				{
					bstInsert += ",";
				}	
			}
			bstInsert += ") VALUES (";
			for (int j = 0; j < numValidColsSet; j++)
			{
				if (xMultiSet->val.array.lparray[i * numValidColsSet + j].xltype == 2)
				{
					std::string strTemp = operToString(&xMultiSet->val.array.lparray[i * numValidColsSet + j]);
					bstInsert = bstInsert + "'" + _bstr_t(_com_util::ConvertStringToBSTR(strTemp.c_str())) + "'";
				}
				else if (xMultiSet->val.array.lparray[i * numValidColsSet + j].xltype == 1)
				{
					bstInsert += _bstr_t(xMultiSet->val.array.lparray[i * numValidColsSet + j].val.num);
				}
				if (j != numValidColsSet - 1)
				{
					bstInsert += ",";
				}
			}
			bstInsert += ")";

			_variant_t RecordsAffected;
			HRESULT hr = m_pConnection->Execute(bstInsert, &RecordsAffected, adCmdText);			
		}

		// Close all pointers
		delete[] pKeyWords;

		if(m_pRecordset->State)
			m_pRecordset.Release();
		m_pRecordset = NULL;

		if(m_pConnection->State)
			m_pConnection->Close();
		m_pConnection= NULL;

		//Judge the operation success or not
		if (SUCCEEDED(hr))
		{
			return "ContribSuccess";
		}
		else
		{
			return "ContribFailed";
		}
	}
	catch(_com_error &e)
	{
		// Close all pointers
		if(m_pRecordset->State)
			m_pRecordset.Release();
		m_pRecordset = NULL;

		if(m_pConnection->State)
			m_pConnection->Close();
		m_pConnection= NULL;

		ObjectHandler::RepositoryXL::instance().logError((LPCSTR)e.Description(), functionCall);
		return 0;
	}
	catch(const std::exception &e)
	{
		// Close all pointers
		if(m_pRecordset->State)
			m_pRecordset.Release();
		m_pRecordset = NULL;

		if(m_pConnection->State)
			m_pConnection->Close();
		m_pConnection= NULL;

		ObjectHandler::RepositoryXL::instance().logError(e.what(), functionCall);
		return 0;
	}catch (...) 
	{
		// Close all pointers
		if(m_pRecordset->State)
			m_pRecordset.Release();
		m_pRecordset = NULL;

		if(m_pConnection->State)
			m_pConnection->Close();
		m_pConnection= NULL;

		ObjectHandler::RepositoryXL::instance().logError("Unknown Error Type", functionCall);
		return 0;
	}
}

/* This function  extracts the meaningful part of a Pascal-style STRING value that is being returned by Excel API.
   The first BYTE stores the total characters in the string; then follows those characters(actual string), 
   followed by what seems like Excel garbage! 

*/
int  ExcelStr2CStr(const LPSTR  lpInStr, char* pcOutStr, const int cnOutBufLen )
{
    const int cnLen = lpInStr[0]; // get the length sotred in the first byte..(a Pascal-style String?)
    memset(pcOutStr, cnOutBufLen, '\0');
    int i=0;

    for ( i=1; i <= cnLen ; i++) // extract c-string out of Pascal-style String..
    {
        pcOutStr[i-1] = lpInStr[i];
    }
// null-terminate string to make it compatible with all string processing functions/requirements
    pcOutStr[i-1] ='\0'; 
    return i-1; // since we started counting at index 1, and not 0.
}

// Get unique list of a range

bool isTwoCellTheSame(const OPER *xTarget, const OPER *xSource)
{
	//OH_REQUIRE(xSource->xltype == xTarget->xltype, "xSource and xTarget must have the same type");
	static char buf[SMALL_STRING_LEN];
	char   cSource[SMALL_STRING_LEN];
	char   cTarget[SMALL_STRING_LEN];
	if (xSource->xltype == xltypeNum) {
		if(xTarget->val.num == xSource->val.num)
			return true;
	} else if (xSource->xltype == xltypeStr | xlbitDLLFree) {
		ExcelStr2CStr(xSource->val.str, buf, SMALL_STRING_LEN);
		strcpy(cSource,buf);
		ExcelStr2CStr(xTarget->val.str, buf, SMALL_STRING_LEN);
		strcpy(cTarget,buf);
		if(!strcmp(cSource, cTarget))
		{
			return true;
		}
	}
	else{
		OH_FAIL("Unable to handle different cell value types in function isTwoCellTheSame");
	}
	return false;
}

bool alIsElementInRange(const OPER *xTarget, const OPER *xSource, int iStartIndex, int iEndIndex)
{
	ObjectHandler::Xloper xMultiSource;	
	Excel(xlCoerce, &xMultiSource, 2, xSource, TempInt(xltypeMulti));
	OH_REQUIRE(xMultiSource->val.array.rows >= 1, "alIsElementInRange: xSource range must have at least one row");
	OH_REQUIRE(xMultiSource->val.array.rows >= iEndIndex, "alIsElementInRange: iEndIndex should not be bigger than the max size of xSource range");
	

	for( int i = iStartIndex; i < iEndIndex; i++)
	{
		if(isTwoCellTheSame(xTarget,&xMultiSource->val.array.lparray[i])){
			return true;
		}
	}

	return false;

}

XLL_DEC double *alRangeSumIf(OPER *xTargetRange,OPER *xFilterRange,OPER *xSumRange)
{
	// initialize Function Call object
	boost::shared_ptr<ObjectHandler::FunctionCall> functionCall;

	ObjectHandler::Xloper xMulti;
	ObjectHandler::Xloper xMultiSum;
	ObjectHandler::Xloper xMultiFilter;
	static double dRet;
	int numRows = 1;
	int indexSource = 0;
	int indexTarget = 0;

	try {
		functionCall = boost::shared_ptr<ObjectHandler::FunctionCall>
			(new ObjectHandler::FunctionCall("alRangeSumIf"));

		Excel(xlCoerce, &xMulti, 2, xTargetRange, TempInt(xltypeMulti));
		OH_REQUIRE(countValidColumns(xMulti())==1,"alRangeSumIf: The range to be merged must have only one valid col");
		OH_REQUIRE(countValidRows(xMulti())>=1,"alRangeSumIf: The range to be merged must have at least one valid row");

		Excel(xlCoerce, &xMultiFilter, 2, xFilterRange, TempInt(xltypeMulti));
		OH_REQUIRE(countValidColumns(xMultiFilter())==1,"alRangeSumIf: The range to be merged must have only one valid col");
		OH_REQUIRE(countValidRows(xMultiFilter())>=1,"alRangeSumIf: The range to be merged must have at least one valid row");

		Excel(xlCoerce, &xMultiSum, 2, xSumRange, TempInt(xltypeMulti));
		OH_REQUIRE(countValidColumns(xMultiSum())==1,"alRangeSumIf: The range to be merged must have only one valid col");
		OH_REQUIRE(countValidRows(xMultiSum())>=countValidRows(xMulti()),"alRangeSumIf: The range to be merged must have at least one valid row");

		dRet = 0.0;
		for (int i=0; i < xMulti->val.array.rows; ++i) {
			if(rowIsValid(xMulti(),i) && alIsElementInRange(&xMulti->val.array.lparray[i], xFilterRange, 0, xMultiFilter->val.array.rows))
			{
				dRet += xMultiSum->val.array.lparray[i].val.num;
			}
		}

		return &dRet;

	} catch (const std::exception &e) {

		// log the exception and return a null pointer (#NUM!) to Excel

		ObjectHandler::RepositoryXL::instance().logError(e.what(), functionCall);
		return 0;
	}

}

XLL_DEC OPER *alGetUniqueList(OPER *xInputRange)
{
	// initialize Function Call object
	boost::shared_ptr<ObjectHandler::FunctionCall> functionCall;

	ObjectHandler::Xloper xMulti;
	static OPER xRet;
	xRet.val.array.lparray = 0;
	int numRows = 1;
	int numValidCols = 0;
	int numValidRows = 0;
	int indexSource = 0;
	int indexTarget = 0;

	try {
		functionCall = boost::shared_ptr<ObjectHandler::FunctionCall>
			(new ObjectHandler::FunctionCall("alGetUniqueList"));

		Excel(xlCoerce, &xMulti, 2, xInputRange, TempInt(xltypeMulti));
		
		numValidCols = countValidColumns(xMulti());	
		OH_REQUIRE(numValidCols==1,"The range to be merged must have only one valid col");
		
		numValidRows = countValidRows(xMulti());
		OH_REQUIRE(numValidRows>=1,"The range to be merged must have at least one valid row");

		xRet.val.array.rows = 1;
		xRet.val.array.columns = 1; //only one col
		//xRet.val.array.lparray = new OPER[numRows]; 
		xRet.val.array.lparray = (OPER*) malloc(1*sizeof(OPER));
		xRet.xltype = xltypeMulti | xlbitDLLFree;

		for (int i=0; i < xMulti->val.array.rows; ++i) {
			if(rowIsValid(xMulti(),i) && indexTarget == 0)
			{
				indexSource = i;
				operToOper(&xRet.val.array.lparray[indexTarget], 
					&xMulti->val.array.lparray[indexSource]);
				indexTarget += 1;
				xRet.val.array.rows = 1;
			}
			else if(rowIsValid(xMulti(),i) && !alIsElementInRange(&xMulti->val.array.lparray[i],&xRet,0,xRet.val.array.rows))
			{
				//need to reallocate memory
				xRet.val.array.lparray = (OPER*) realloc(xRet.val.array.lparray, (indexTarget+1)*sizeof(OPER));
				indexSource = i;
				operToOper(&xRet.val.array.lparray[indexTarget], 
					&xMulti->val.array.lparray[indexSource]);
				indexTarget += 1;
				xRet.val.array.rows += 1; 
			}
		}

		return &xRet;

	} catch (const std::exception &e) {

		// free any memory that may have been allocated

		if (xRet.xltype & xltypeMulti && xRet.val.array.lparray) {
			for (int i=0; i<xRet.val.array.columns * xRet.val.array.rows; ++i) {
				if (xRet.val.array.lparray[i].xltype & xltypeStr && xRet.val.array.lparray[i].val.str)
					delete [] xRet.val.array.lparray[i].val.str;
			}
			delete [] xRet.val.array.lparray;
		}

		// log the exception and return a null pointer (#NUM!) to Excel

		ObjectHandler::RepositoryXL::instance().logError(e.what(), functionCall);
		return 0;
	}
}

XLL_DEC OPER *alIsConsecutiveTrend(OPER *xInputRange, OPER* threshhold)
{
	boost::shared_ptr<ObjectHandler::FunctionCall> functionCall;
	ObjectHandler::Xloper xMulti;
	ObjectHandler::Xloper xThresh;
	double iResult = 1.0;
	static OPER xRet;

	try {
		functionCall = boost::shared_ptr<ObjectHandler::FunctionCall>
			(new ObjectHandler::FunctionCall("alIsConsecutiveTrend"));

		Excel(xlCoerce, &xMulti, 2, xInputRange, TempInt(xltypeMulti));
		Excel(xlCoerce, &xThresh, 2, threshhold, TempInt(xltypeMulti));
		OH_REQUIRE(xMulti->val.array.rows>=1, "input range must have at least one rows");
		//OH_REQUIRE(xThresh->val.array.rows==1, "threshhold value must be value from one single cell");
		//OH_REQUIRE(xThresh->val.array.lparray[0].xltype==xltypeNum, "threshhold value must be a number");
		bool bThreshhold = ObjectHandler::convert2<bool>(
			ObjectHandler::ConvertOper(*threshhold), "", true);

		//xRet.val.array.lparray = new OPER[1];
		//xRet.val.array.rows = 1;
		//xRet.val.array.columns = 1;
		//xRet.xltype = xltypeMulti | xlbitDLLFree;
		//xRet.val.array.lparray[0].xltype==xltypeNum;
		//xRet.val.array.lparray[0].val.num = 1;
		for(int i = 0; i < xMulti->val.array.rows; i++)
		{
			OH_REQUIRE(xMulti->val.array.lparray[i].xltype==xltypeNum, "input range values must be numbers");
			if(bThreshhold)// check if everyone is positive
			{
				if(xMulti->val.array.lparray[i].val.num <= 0 )
				{
					iResult = 0;
					break;
				}
			}
			else{ // check if everyone is negative
				if(xMulti->val.array.lparray[i].val.num >= 0 )
				{
					iResult = 0;
					break;
				}
			}
		}
		
		ObjectHandler::scalarToOper(iResult, xRet);
		return &xRet;

	} catch (const std::exception &e) {


		if (xRet.xltype & xltypeMulti && xRet.val.array.lparray) {
			for (int i=0; i<xRet.val.array.columns * xRet.val.array.rows; ++i) {
				if (xRet.val.array.lparray[i].xltype & xltypeStr && xRet.val.array.lparray[i].val.str)
					delete [] xRet.val.array.lparray[i].val.str;
			}
			delete [] xRet.val.array.lparray;
		}

		ObjectHandler::RepositoryXL::instance().logError(e.what(), functionCall);
		return 0;
	}
}
